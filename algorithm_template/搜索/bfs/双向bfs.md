
/*

使用场景:

* 确定起点和终点

* 当单向bfs超时(由于状态太多, 导致树太大), 可以考虑双向

*/



「双向 BFS」的基本实现思路如下:

* 创建「两个队列」分别用于两个方向的搜索；

* 创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；

* 为了尽可能让两个搜索方向“平均”，优先扩展队列元素小的那个方向

* 如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。

伪代码:
```cpp
vector<状态>q1, q2; 分别为两个方向的队列
unordered_map<状态, 步数> dis1, dis2; 分别为两个方向的哈希表，记录自己那个方向扩展的所有节点距离自己那个方向起点的步数
    
// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点, 即无解
while(q1.size() && q2.size()) {
    if (q1.size() < q2.size()) update(q1, vis1, vis2); // 更新q1这个方向
    else update(q2, vis2, vis1); // 更新q2这个方向
}

// update: 将队列q扩展一层, 如果与另一个方向的节点相遇, 说明有解, 那么起点到终点的距离=起点和终点到相遇点的步数之和
void update(vector<状态>& q, unordered_map<状态>& cur, unordered_map<状态>& other) {
    
}
```
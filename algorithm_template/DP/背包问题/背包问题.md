## 思考点

哪种背包 + 哪种问题 + 是否考虑顺序（只针对完全背包而言）

## 背包种类

**前提**:

物品i的重量为nums[i], 价值为value[i], 数量为s[i]
背包的容量为j, 上限为target

1. 0/1背包：外循环物品i, 内循环背包容量j, j倒序且j>=nums[i]; 更新dp[j]
2. 完全背包：
    如果不考虑元素间的顺序(组合问题)：外循环物品i, 内循环背包容量j, j正序且j>=nums[i]; 更新dp[j]
    如果需要考虑顺序(排列问题)：外循环背包容量j，内循环物品i，i正序; 更新dp[j]
3. 多重背包：
   4.1 简单将物品i的数量s[i]展开, 看做s[i]个不同物品, 用0/1背包做即可
   4.2 按照递增的思想把物品i的数量s[i]分成logs[i]堆，每堆看做一种新物品，转换为0/1背包问题
4. 分组背包：共groups个物品组, 每个组内至少选一个/必须选一个
   二维写法dp[i][j]: 先循环物品组i, 再循环背包容量j(正序), 再循环从物品组i选出的物品k. f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);
   一维写法dp[j]:    先循环物品组i, 再循环背包容量j(逆序), 再循环从物品组i选出的物品k. f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);


## 问题种类

1、最值问题：要求最大值/最小值, dp[j] = max/min(dp[j], dp[j - num[i]] + 物品i的价值); 物品i的价值可能是1, nums[i], value[i]等等
2、存在问题(bool)：是否存在…………，满足…………, dp[j] = dp[j] | dp[j - nums[i]];
3、计数问题：求所有满足……的排列组合, dp[j] += dp[j - nums[i]];

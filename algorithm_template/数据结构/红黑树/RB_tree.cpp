
/*




1.1 性质
    (1) 节点是红色或黑色
    (2) 根节点是黑色
    (3) 所有叶子都是黑色(rbt的叶子指的是通常意义上的叶子的两个NULL儿子)
    (4) 红色节点的两个儿子都是黑色(也就是不存在连续的红色点)
    (5) 从任一节点到它的每个叶子的所有路径都包含相同数目的黑色节点
    (6) 从根到叶子的最长路径 < 2*最短路径, 保证了树高比较均衡
        证明: 假设从根到叶子有k个黑色点,那么最短路径是纯黑,即k个黑色点;最长是k+(k-1),即每两个黑色点之间插1个红色点,且以黑色点结尾,那么最长路径为2k-1
1.3
    插入操作: 先按BST插入新节点x, 新插入点设为红色, 再维护红黑树的性质
        情况1: 原本为空树, 插入x后, x作为根节点需要设为黑色
        情况2: x的父节点是黑色: 把该点染成红色即可
        情况3: x的父节点是红色
            情况3.1: x的叔叔节点(爷爷节点的另一个儿子)也是红色
                (1) 将父节点设为黑色
                (2) 将叔节点设为黑色
                (3) 将爷爷设为红色
                (4) 由于将爷爷设为红色, 那么爷爷跟上层节点可能冲突(连续红色点);
                    因此将爷爷设为"当前节点", 继续对"当前节点"递归操作
            情况3.2: x的叔叔节点是黑色, 且x是其父亲的右儿子
                (1) 将父节点作为"新的当前节点"
                (2) 以"新的当前节点"为支点进行左旋
            情况3.3: 叔叔是黑色, 且x是其父亲的左儿子
                (1) 将"父节点"设为黑色
                (2) 将"爷爷节点"设为红色
                (3) 以"爷爷节点"为支点进行右旋

    删除操作: 先按BST删除节点x, 再维护红黑树的性质
        情况1: 如果x是红色, 那么按BST删除该点后,不需要任何额外操作
        情况2: 如果x是黑色, 删除x之后该位置会放一个红或黑节点, 那么就得到一个"红+黑"或"黑+黑", 称呼该位置仍为x
            情况2.1: x是"红+黑": 将x设为黑色
            情况2.2: x是根节点: 将x设为黑色
            情况2.3: x指向一个"黑+黑"节点:
                情况2.3.1: x的兄弟是红色
                    (1) 将x的兄弟设为黑色
                    (2) 将x的父亲设为红色
                    (3) 对x的父亲左旋
                    (4) 左旋后, 重新设置x的兄弟节点
                情况2.3.2: x的兄弟是黑色, x的兄弟的两个儿子都是黑色
                    (1) 将x的兄弟设为红色
                    (2) 将x的父亲设为"新的x节点"
                情况2.3.3: x的兄弟是黑色, x的兄弟的左儿子是红色, 右儿子是黑色
                    (1) 将x兄弟的左儿子设为黑
                    (2) 将x兄弟设为"红色"
                    (3) 对x的兄弟进行右旋
                    (4) 右旋后, 重新设置x的兄弟节点
                情况2.3.4: x的兄弟是黑色, x的兄弟的右儿子是红色, 左儿子是任意颜色
                    (1) 将x父亲颜色赋值给x的兄弟
                    (2) 将x父亲设为黑色
                    (3) 将x兄弟的右儿子设为黑色
                    (4) 对x的父亲进行左旋




    1.3.3 修改(等价于先删再插)


*/
/*
 * KMP: 找到模式串p在主串s中所有出现的下标位置
 *
 * 下面yxc写法, 虽然读到1开始的地方, 但是最终结果还是按0开始的
 *
 *
 *
 */

#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, M = 1e6 + 10; // 模式串最大长度N, 主串最大长度M
int n, m;//模式串p长为n，主串s长为m
char p[N], s[M];//模式串p，主串s
int ne[N];//模式串p的next数组

// 构造next数组
void build_next() {
    for (int i = 2, j = 0; i <= n; ++i) {//求模式串p的next数组，next[0],next[1]肯定为0
        while (j && p[i] != p[j + 1]) j = ne[j];//若i和j+1匹配失败，就把j不断后退，直到回退到原地(j==0)或p[i]==p[j+1]
        if (p[i] == p[j + 1]) ++j;//本身[1,j]这一段是匹配成功的，现在j+1这个位置也匹配成功了，因此成功匹配的长度+1
        ne[i] = j;//无论j是否后退到0，i和j+1这个位置是否匹配，都要更新ne[i]
    }
}

void KMP() {
    cin >> n >> p + 1 >> m >> s + 1; //将两个串读到下标1开始的地方
    build_next();
    
    // 依次输出p在s中出现的位置
    for (int i = 1, j = 0; i <= m; ++i) { //kmp 匹配过程
        while (j && s[i] != p[j + 1]) j = ne[j];//若s[i]和p[j+1]不匹配，则j不断后退，直到退到0或者退到某个位置使其s[i]==p[j+1]
        if (s[i] == p[j + 1]) ++j;//说明模式串的[1,j+1]这一段与主串的[i-j,i]这一段匹配成功，就进入下层循环尝试匹配二者的下个位置
        if (j == n) {//模式串成功匹配[1,n]这一段
            cout << i - n << ' ';//此时的主串起始位置是i-n+1,但我们最初将数据读到1开始的地方，因此实际起始位置应该再-1
            j = ne[j];//又回到最初的问题，模式串的[1,n]这一段与主串的[i-n+1,i]这一段匹配成功,笨办法是尝试以主串i+n+1的下个位置作为起始位置去跟模式串匹配，但模式串的[1,ne[j]]这一段是匹配成功，因此下层循环++i后，接着比s[i]和p[j+1]
        }
    }
}